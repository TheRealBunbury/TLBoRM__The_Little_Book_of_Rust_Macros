<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parsing Rust - The Little Book of Rust Macros</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../res/rust-syntax-bg-highlight.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "ayu";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Little Book of Rust Macros</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/veykril/tlborm/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="parsing-rust"><a class="header" href="#parsing-rust">Parsing Rust</a></h1>
<p>Parsing some of Rust's items can be useful in certain situations.
This section will show a few macros that can parse some of Rust's more complex items like structs and functions to a certain extent.
The goal of these macros is not to be able to parse the entire grammar of the items but to parse parts that are in general quite useful without being too complex to parse. This means we ignore things like generics and such.</p>
<p>The main points of interest of these macros are their <code>matchers</code>.
The transcribers are only there for example purposes and are usually not that impressive.</p>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! function_item_matcher {
    (

        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis fn $name:ident ( $( $arg_name:ident : $arg_ty:ty ),* $(,)? )
    //                          ^~~~~~~~~~~~~~~~argument list~~~~~~~~~~~~~~~^
            $( -&gt; $ret_ty:ty )?
    //      ^~~~return type~~~^
            { $($tt:tt)* }
    //      ^~~~~body~~~~^
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -&gt; $ret_ty )? { $($tt)* }
    }
}

<span class="boring">function_item_matcher!(
</span><span class="boring">    #[inline]
</span><span class="boring">    #[cold]
</span><span class="boring">    pub fn foo(bar: i32, baz: i32, ) -&gt; String {
</span><span class="boring">        format!("{} {}", bar, baz)
</span><span class="boring">    }
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo(13, 37), "13 37");
</span><span class="boring">}</span></code></pre></pre>
<p>A simple function matcher that ignores qualifiers like <code>unsafe</code>, <code>async</code>, ... as well as generics and where clauses.
If parsing those is required it is likely that you are better off using a proc-macro instead.</p>
<p>This lets you for example, inspect the function signature, generate some extra things from it and then re-emit the entire function again.
Kind of like a <code>Derive</code> proc-macro but weaker and for functions.</p>
<blockquote>
<p>Ideally we would like to use a pattern fragment specifier instead of an ident for the arguments but this is currently not allowed.
Fortunately people don't use non-identifier patterns in function signatures that often so this is okay(a shame, really).</p>
</blockquote>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<p>The macro for parsing basic functions is nice and all, but sometimes we would like to also parse methods, functions that refer to their object via some form of <code>self</code> usage. This makes things a bit trickier:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! method_item_matcher {
    // self
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis fn $name:ident ( $self:ident $(, $arg_name:ident : $arg_ty:ty )* $(,)? )
    //                          ^~~~~~~~~~~~~~~~~~~~~argument list~~~~~~~~~~~~~~~~~~~~~~^
            $( -&gt; $ret_ty:ty )?
    //      ^~~~return type~~~^
            { $($tt:tt)* }
    //      ^~~~~body~~~~^
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( $self $(, $arg_name : $arg_ty )* ) $( -&gt; $ret_ty )? { $($tt)* }
    };

    // mut self
    (
        $( #[$meta:meta] )*
        $vis:vis fn $name:ident ( mut $self:ident $(, $arg_name:ident : $arg_ty:ty )* $(,)? )
            $( -&gt; $ret_ty:ty )?
            { $($tt:tt)* }
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( mut $self $(, $arg_name : $arg_ty )* ) $( -&gt; $ret_ty )? { $($tt)* }
    };

    // &amp;self
    (
        $( #[$meta:meta] )*
        $vis:vis fn $name:ident ( &amp; $self:ident $(, $arg_name:ident : $arg_ty:ty )* $(,)? )
            $( -&gt; $ret_ty:ty )?
            { $($tt:tt)* }
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( &amp; $self $(, $arg_name : $arg_ty )* ) $( -&gt; $ret_ty )? { $($tt)* }
    };

    // &amp;mut self
    (
        $( #[$meta:meta] )*
        $vis:vis fn $name:ident ( &amp;mut $self:ident $(, $arg_name:ident : $arg_ty:ty )* $(,)? )
            $( -&gt; $ret_ty:ty )?
            { $($tt:tt)* }
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( &amp;mut $self $(, $arg_name : $arg_ty )* ) $( -&gt; $ret_ty )? { $($tt)* }
    }
}

<span class="boring">struct T(i32);
</span><span class="boring">impl T {
</span><span class="boring">    method_item_matcher!(
</span><span class="boring">        #[inline]
</span><span class="boring">        pub fn s(self, x: i32) -&gt; String { format!("{}", x) }
</span><span class="boring">    );
</span><span class="boring">    method_item_matcher!(
</span><span class="boring">        pub fn ms(mut self, x: i32,) -&gt; String { format!("{}", x) }
</span><span class="boring">    );
</span><span class="boring">    method_item_matcher!(
</span><span class="boring">        pub fn rs(&amp;self, x: i32, y: i32) -&gt; String { format!("{}", self.0 + x + y) }
</span><span class="boring">    );
</span><span class="boring">    method_item_matcher!(
</span><span class="boring">        pub fn rms(&amp;mut self) -&gt; String { self.0.to_string() }
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!({ let t = T(11); t.s(11) }, "11");
</span><span class="boring">    assert_eq!({ let t = T(22); t.ms(22) }, "22");
</span><span class="boring">    assert_eq!({ let t = T(30); t.rs(1, 2) }, "33");
</span><span class="boring">    assert_eq!({ let mut t = T(44); t.rms() }, "44");
</span><span class="boring">}</span></code></pre></pre>
<p>The four rules are identical except for the <code>self</code> receiver on both sides of the rule, which is <code>self</code>, <code>mut self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>.
You might not need all four rules.</p>
<p><code>$self:ident</code> must be used in the matcher instead of a bare <code>self</code>.
Without that, uses of <code>self</code> in the body will cause compile errors, because a macro invocation can only access identifiers it receives from parameters.</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! struct_item_matcher {
    // Unit-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident;
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name;
    };

    // Tuple-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident (
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~~^
                $field_vis:vis $field_ty:ty
    //          ^~~~~~a single field~~~~~~^
            ),*
        $(,)? );
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name (
            $(
                $( #[$field_meta] )*
                $field_vis $field_ty
            ),*
        );
    };

    // Named-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident {
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~!^
                $field_vis:vis $field_name:ident : $field_ty:ty
    //          ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
            ),*
        $(,)? }
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name {
            $(
                $( #[$field_meta] )*
                $field_vis $field_name : $field_ty
            ),*
        }
    }
}

<span class="boring">struct_item_matcher!(
</span><span class="boring">    #[derive(Copy, Clone)]
</span><span class="boring">    pub(crate) struct Foo {
</span><span class="boring">       pub bar: i32,
</span><span class="boring">       baz: &amp;'static str,
</span><span class="boring">       qux: f32
</span><span class="boring">    }
</span><span class="boring">);
</span><span class="boring">struct_item_matcher!(
</span><span class="boring">    #[derive(Copy, Clone)]
</span><span class="boring">    pub(crate) struct Bar;
</span><span class="boring">);
</span><span class="boring">struct_item_matcher!(
</span><span class="boring">    #[derive(Clone)]
</span><span class="boring">    pub(crate) struct Baz (i32, pub f32, String);
</span><span class="boring">);
</span><span class="boring">fn main() {
</span><span class="boring">    let _: Foo = Foo { bar: 42, baz: "macros can be nice", qux: 3.14, };
</span><span class="boring">    let _: Bar = Bar;
</span><span class="boring">    let _: Baz = Baz(2, 0.1234, String::new());
</span><span class="boring">}</span></code></pre></pre>
<h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<p>Parsing enums is a bit more complex than structs so we will finally make use of some of the <a href="../patterns.html">patterns</a> we have discussed, <a href="../patterns/tt-muncher.html">Incremental TT Muncher</a> and <a href="../patterns/internal-rules.html">Internal Rules</a>.
Instead of just building the parsed enum again we will merely visit all the tokens of the enum, as rebuilding the enum would require us to collect all the parsed tokens temporarily again via a <a href="../patterns/push-down-acc.html">Push Down Accumulator</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! enum_item_matcher {
    // tuple variant
    (@variant $variant:ident (
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~~^
            $field_vis:vis $field_ty:ty
    //      ^~~~~~a single field~~~~~~^
        ),* $(,)?
    //∨~~rest of input~~∨
    ) $(, $($tt:tt)* )? ) =&gt; {

        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // named variant
    (@variant $variant:ident {
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~!^
            $field_vis:vis $field_name:ident : $field_ty:ty
    //      ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
        ),* $(,)?
    //∨~~rest of input~~∨
    } $(, $($tt:tt)* )? ) =&gt; {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // unit variant
    (@variant $variant:ident $(, $($tt:tt)* )? ) =&gt; {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // trailing comma
    (@variant ,) =&gt; {};
    // base case
    (@variant) =&gt; {};
    // entry point
    (
        $( #[$meta:meta] )*
        $vis:vis enum $name:ident {
            $($tt:tt)*
        }
    ) =&gt; {
        enum_item_matcher!(@variant $($tt)*)
    };
}

<span class="boring">enum_item_matcher!(
</span><span class="boring">    #[derive(Copy, Clone)]
</span><span class="boring">    pub(crate) enum Foo {
</span><span class="boring">        Bar,
</span><span class="boring">        Baz,
</span><span class="boring">    }
</span><span class="boring">);
</span><span class="boring">enum_item_matcher!(
</span><span class="boring">    #[derive(Copy, Clone)]
</span><span class="boring">    pub(crate) enum Bar {
</span><span class="boring">        Foo(i32, f32),
</span><span class="boring">        Bar,
</span><span class="boring">        Baz(),
</span><span class="boring">    }
</span><span class="boring">);
</span><span class="boring">enum_item_matcher!(
</span><span class="boring">    #[derive(Clone)]
</span><span class="boring">    pub(crate) enum Baz {}
</span><span class="boring">);
</span><span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../decl-macros/building-blocks/abacus-counting.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../decl-macros/macros2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../decl-macros/building-blocks/abacus-counting.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../decl-macros/macros2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
